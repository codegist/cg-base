<link href="../polymer/polymer.html" rel="import">

<polymer-element name="cg-base" attributes="ownerId listensTo cgName dataContext">
<script>
    (function(){
        var id = 1;
        var GLOBALS = {
            ignoreVisibilityOnDataRequest:[],
            context:{
            }
        };
        var RunOnVisible = function(){
            this.elements = {};
            this.keys = [];
            this.interval = null;
        };
        RunOnVisible.prototype = {
            runOrEnqueueIfNotVisible:function(element, callback, scope){
                if(GLOBALS.ignoreVisibilityOnDataRequest.indexOf(element.constructor.name) != -1 || this._isElementVisible(element)) {
                    return callback.call(scope);
                }
                this.elements[element._cgbaseId] = {
                    el:element,
                    callback:callback,
                    scope:scope
                };
                this._elementsChanged();
            },
            _elementsChanged:function(){
                this.keys = Object.keys(this.elements);
            },
            start:function(options){
                this.interval = setInterval(this._check.bind(this), options.pooling || 500);
                return this;
            },
            stop:function(){
                this.interval && clearInterval(this.interval);
                return this;
            },
            _check:function(){
                var len = this.keys.length;
                if(len == 0) {
                    return;
                }
                console.log("[cg-base] VisibilityChecker cycle (contains:" + len + " elements)");
                var desc, changed = false;
                for(var i = 0; i < len;i++){
                    desc = this.elements[this.keys[i]];
                    if(this._isElementVisible(desc.el)) {
                        delete this.elements[this.keys[i]];
                        console.log("[cg-base] VisibilityChecker element " + desc.el.constructor.name + " has been made visible, running callback");
                        desc.callback.call(desc.scope);
                        changed = true;
                    }
                }
                if(changed) {
                    this._elementsChanged();
                }
            },
            _isElementVisible:function(element){
                return document.defaultView.getComputedStyle(element, null).visibility != "hidden";
            },
            remove:function(element){
                delete this.elements[element._cgbaseId];
                this._elementsChanged();
            },
        };

        var RUN_ON_VISIBLE = new RunOnVisible().start({pooling:100});

        Polymer({
            listensTo:["cg-application-event"],
            _handlerMap:{
                "cg-application-event" : "onApplicationEvent",
                "cg-application-error" : "onApplicationError",
                "cg-application-link" : "onApplicationLink"
            },
            _cgbaseId:0,
            cgName:null,
            self:null,
            _eventsHandlers:{},
            elementVisible:true,
            globals:null,
            dataContext:null,
            _globalsContextObs:null,
            created:function(){
                this._cgbaseId = id++;
                this.self = this;
                console.log("["+this.constructor.name+"] Created with id " + this._cgbaseId);
                this.globals = GLOBALS;
                this._globalsContextObs = new PathObserver(GLOBALS, "context");
                this._globalsContextObs.open(function(){this.contextChanged()}.bind(this));
                this.listensToChanged();
            },
            detached:function(){
                RUN_ON_VISIBLE.remove(this);
                console.log("["+this.constructor.name+"] detached");
            },
            listensToChanged:function(){
                for(var key in this._eventsHandlers){
                    var e = this._eventsHandlers[key];
                    Polymer.removeEventListener(e.node, e.event, e.handler);
                }
                this._eventsHandlers = {};
                for(var i = 0; i < this.listensTo.length; i++){
                    if(!this._handlerMap.hasOwnProperty(this.listensTo[i])) {
                        throw "unknown handler " + this.listensTo[i];
                    }
                    var handler = this[this._handlerMap[this.listensTo[i]]];
                    this._listensTo(this.listensTo[i], handler);
                }
            },
            _listensTo:function(event, callback){
                var handler = function(e){
                    console.log("["+this.constructor.name+"] receiving "+event+"[type:"+e.detail.type+"]");
                    callback.call(this, e.detail.type, e.detail, e);
                }.bind(this);
                Polymer.addEventListener(document, event, handler);
                this._eventsHandlers[event] = {
                    handler:handler,
                    event:event,
                    node:document
                };
            },
            domReady:function(){
                this.async(this.contextChanged);
            },
            fireApplicationLink:function(type, params, source){
                this._fireApplication("cg-application-link", type, params, source);
            },
            fireApplicationError:function(type, params, source){
                this._fireApplication("cg-application-error", type, params, source);
            },
            fireApplicationEvent:function(type, params, source){
                this._fireApplication("cg-application-event", type, params, source);
            },
            _fireApplication:function(eventType, type, params, source){
                console.log("["+this.constructor.name+"] fireApplication(type:"+type+", params:"+CGUtils.json.stringify(params, true, 40)+")");
                this.asyncFire(eventType, {
                    type:type,
                    params:params,
                    source:source || this
                }, document);
            },
            fireDataRequest:function(options){
                options.type = (options.typePrefix !== false ? (this.cgName || this.constructor.name) + "/" : "") + options.type;
                options.source = options.source || this;
                options.params = options.params || {};
                options.params.context = this.dataContext || {};
                console.log("["+this.constructor.name+"] fireDataRequest(type:"+options.type+", params:"+CGUtils.json.stringify(options.params, true, 40)+")");
                // TODO WORK ON THIS
                this.doIfVisible(function(){ // TODO should be only valid if request is a read one!!!!!
                    this.asyncFire("cg-data-request", options, document);
                });
            },
            isDataAware:function(){
                return this.globals.dataAware;
            },
            dataContextChanged:function(){
                console.log("["+this.constructor.name+"] dataContextChanged()");
                this.reload();
            },
            reload:function(){},
            contextChanged:function(){
                console.log("["+this.constructor.name+"] contextChanged()");
            },
            globalsChanged:function(){
                console.log("["+this.constructor.name+"] globalsChanged()");
            },
            onApplicationLink:function(type, event, e){},
            onApplicationEvent:function(type, event, e){},
            onApplicationError:function(type, event, e){},
            doIfVisible:function(callback, scope){
                RUN_ON_VISIBLE.runOrEnqueueIfNotVisible(this, callback, scope || this);
            },
            setGlobal:function(name, value){
                if(!value) {
                    throw "Value for "+name+" global must be given";
                }
                var exists = GLOBALS.hasOwnProperty(name);
                if(typeof value === "function") {
                    if(exists) {
                        value.call(this, GLOBALS[name]);
                    }else{
                        throw name + " not found";
                    }
                }else{
                    GLOBALS[name] = value;
                }
                return GLOBALS[name];
            },
            removeGlobal:function(name){
                var val = GLOBALS[name];
                delete GLOBALS[name];
                return val;
            },
            getGlobal:function(name){
                return GLOBALS[name];
            },
            listenOnce: function(event, fn, args) {
                var self = this;
                var listener = function() {
                    fn.apply(self, [].slice.call(arguments).concat(args));
                    this.removeEventListener(event, listener, false);
                };
                this.addEventListener(event, listener, false);
            },
        });
    })();
</script>
</polymer-element>